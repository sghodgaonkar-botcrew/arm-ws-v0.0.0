/**
 * @mainpage C++ Plugins for Robot Arm Control
 * 
 * @section intro_sec Introduction
 * 
 * This project provides a comprehensive C++ library for robot arm control, featuring inverse kinematics (IK) solving with reachable workspace support, motor control, and workspace generation capabilities. The library is designed for deployment on NVIDIA Jetson Orin Nano and provides efficient, real-time robot arm control.
 * 
 * The system consists of several key components:
 * - **Robot Model**: URDF-based robot representation with kinematics and collision detection
 * - **IK Solver with RWS**: Fast inverse kinematics using pre-computed reachable workspace data
 * - **Workspace Generator**: Tools for generating and sampling robot workspace data
 * - **Motor Controller**: Interface for controlling Moteus motor controllers
 * - **Workspace Types**: Common data structures for workspace representation
 * 
 * @section classes_sec Main Classes
 * 
 * ### @ref RobotModel "RobotModel Class"
 * Core robot model class that loads URDF/SRDF files and provides:
 * - Forward kinematics computation using Pinocchio
 * - Geometric Jacobian calculation
 * - Collision detection with ground clearance
 * - Joint limit management
 * - Pose conversion utilities (SE3 â†” XYZQuat)
 * - Cost function, gradient, and Hessian computation for IK optimization
 * 
 * ### @ref IKSolverWithRWS "IKSolverWithRWS Class"
 * High-performance inverse kinematics solver that provides:
 * - Two-stage IK solving: warm-start + iterative refinement
 * - Spatial indexing with k-d trees and voxel grids
 * - Quadratic programming optimization with line search
 * - Automatic workspace data loading
 * - Support for both XYZQuat and SE3 pose formats
 * - Fast nearest neighbor search for initialization
 * 
 * ### @ref ReachableWorkspaceGenerator "ReachableWorkspaceGenerator Class"
 * Workspace generation tools that provide:
 * - Random sampling within joint limits
 * - Collision detection and validation
 * - Duplicate configuration handling
 * - Multiple output formats (PLY, binary, voxel grid)
 * - Batch processing for efficiency
 * - Hash-based duplicate detection
 * 
 * ### @ref MotorController "MotorController Class"
 * Motor control interface that manages:
 * - Multiple Moteus motor controllers
 * - Position control with acceleration limits
 * - Torque release functionality
 * - Threaded pose holding mechanism
 * - Configurable torque limits
 * - Thread-safe operations
 * 
 * ### Data Structures
 * 
 * #### @ref WorkspacePoint "WorkspacePoint Structure"
 * Structure containing position, rotation, and joint configuration for workspace points.
 * 
 * #### @ref NearestNeighbor "NearestNeighbor Structure"
 * Search result structure with index and distance for nearest neighbor searches.
 * 
 * #### @ref VoxelGrid "VoxelGrid Structure"
 * Sparse voxel grid for spatial indexing and fast neighbor search.
 * 
 * @section features_sec Key Features
 * 
 * - **Real-time Performance**: Optimized for real-time control applications with O(log n) neighbor search
 * - **Collision Avoidance**: Built-in collision detection and ground clearance validation
 * - **Joint Limit Safety**: Automatic joint limit enforcement with velocity bounds
 * - **Multi-motor Support**: Control multiple motors simultaneously with thread safety
 * - **DDS Integration**: Real-time communication using CycloneDDS
 * - **Workspace Pre-computation**: Fast IK solving using pre-generated workspace data
 * - **Spatial Indexing**: Efficient k-d trees and voxel grids for neighbor search
 * - **Robust Optimization**: Quadratic programming with line search for reliable convergence
 * 
 * @section architecture_sec Architecture Overview
 * 
 * The library implements a sophisticated two-stage IK solving approach:
 * 
 * 1. **Warm-start Initialization**: Uses nearest neighbor search in pre-computed workspace data to find good initial joint configurations close to the target pose
 * 2. **Iterative Refinement**: Uses quadratic programming with line search to refine the initial configuration and achieve precise pose matching
 * 
 * The workspace data is stored in binary files containing:
 * - K-d tree data: sampled workspace points with positions, orientations, and joint configs
 * - Voxel grid data: spatial indexing structure for fast neighbor search
 * 
 * @section usage_sec Usage
 * 
 * The system is designed to work with:
 * - URDF/SRDF robot descriptions
 * - Moteus motor controllers
 * - CycloneDDS for communication
 * - Pre-generated workspace data for fast IK solving
 * 
 * Typical usage workflow:
 * 1. Load robot model from URDF/SRDF files
 * 2. Generate workspace data using ReachableWorkspaceGenerator
 * 3. Initialize IK solver with workspace data
 * 4. Solve IK for target poses
 * 5. Control motors using computed joint configurations
 * 
 * @section dependencies_sec Dependencies
 * 
 * ### Required Libraries
 * - **Eigen3**: Linear algebra and geometry operations
 * - **Pinocchio**: Robot kinematics and dynamics
 * - **ProxSuite**: Quadratic programming solver
 * - **Nanoflann**: Efficient k-d tree implementation
 * - **Moteus**: Motor controller library
 * - **CycloneDDS-CXX**: DDS communication
 * - **Boost**: Random number generation and utilities
 * - **OpenMP**: Parallel processing (optional)
 * 
 * ### System Requirements
 * - Ubuntu 22.04.5 LTS or compatible
 * - NVIDIA Jetson Orin Nano (target deployment platform)
 * - C++17 compiler
 * - CMake 3.16+
 * 
 * @section performance_sec Performance Characteristics
 * 
 * ### IK Solver Performance
 * - **Warm-start initialization**: Uses spatial indexing for O(log n) neighbor search
 * - **Iterative refinement**: Quadratic programming with line search for robust convergence
 * - **Typical convergence**: 10-50 iterations for most poses
 * - **Memory usage**: ~100MB for 50K workspace points
 * 
 * ### Workspace Generation Performance
 * - **Sampling efficiency**: 10-30% success rate depending on robot geometry
 * - **Batch processing**: Improves cache locality and reduces memory allocation
 * - **Duplicate detection**: O(1) hash-based lookup
 * - **Output formats**: Binary files for fast loading
 * 
 * ### Motor Control Performance
 * - **Position control**: Non-blocking with acceleration limits
 * - **Thread safety**: Mutex-protected operations
 * - **Torque management**: Immediate release capability
 * - **Real-time operation**: Suitable for control loops
 * 
 * @section build_sec Building
 * 
 * The project uses CMake for building. See the CMakeLists.txt file for detailed build instructions and dependencies.
 * 
 * ```bash
 * cd dds_bridge/cpp_plugins
 * mkdir build && cd build
 * cmake ..
 * make -j$(nproc)
 * ```
 * 
 * @section examples_sec Examples
 * 
 * The library includes comprehensive examples in the `src/` directory:
 * - `example_workspace_generator.cpp`: Basic workspace generation
 * - `test_ik_solver_w_rws.cpp`: IK solving with multiple target poses
 * - `mc_tester.cpp`: Motor control testing
 * - `ik_solver_w_rws_dev.cpp`: Development version with detailed timing
 * 
 * @section deployment_sec Deployment
 * 
 * The library is specifically designed for deployment on NVIDIA Jetson Orin Nano:
 * - Optimized for ARM64 architecture
 * - Memory-efficient data structures
 * - Real-time performance characteristics
 * - Minimal external dependencies
 * 
 * @section troubleshooting_sec Troubleshooting
 * 
 * Common issues and solutions:
 * - **Workspace data not found**: Ensure workspace generation has been run
 * - **IK solver not converging**: Check if target pose is within reachable workspace
 * - **Motor communication errors**: Check USB connections and permissions
 * - **Build errors**: Install all required dependencies and verify C++17 support
 * 
 * For detailed troubleshooting information, see the README.md file in the project root.
 */ 